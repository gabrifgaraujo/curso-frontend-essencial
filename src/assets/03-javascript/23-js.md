# Módulo 3, Aula 23: Promises (Promessas)

Uma **Promise** é um objeto que representa a eventual conclusão (ou falha) de uma operação assíncrona. Ela oferece uma maneira muito mais limpa e gerenciável de lidar com código assíncrono do que os callbacks aninhados.

Uma Promise pode estar em um de três estados:
1.  **Pending (Pendente):** O estado inicial; a operação ainda não foi concluída.
2.  **Fulfilled (Realizada/Resolvida):** A operação foi concluída com sucesso, e a Promise tem um valor resultante.
3.  **Rejected (Rejeitada):** A operação falhou, e a Promise tem um motivo (um erro).

## Consumindo uma Promise

A maneira mais comum de interagir com uma Promise é usando os métodos `.then()` e `.catch()`.

*   `.then(onFulfilled)`: É chamado quando a Promise é resolvida com sucesso. Ele recebe o valor resultante como argumento.
*   `.catch(onRejected)`: É chamado quando a Promise é rejeitada. Ele recebe o erro como argumento.
*   `.finally(onFinally)`: É chamado independentemente de a Promise ter sido resolvida ou rejeitada. Útil para limpeza de código.

```javascript
// fetch() é uma função nativa do navegador que retorna uma Promise.
const promiseDeCep = fetch('https://viacep.com.br/ws/01001000/json/');

console.log("Iniciando a requisição...");

promiseDeCep
  .then(response => {
    // O primeiro .then recebe o objeto de resposta HTTP.
    // response.json() também retorna uma Promise.
    console.log("Resposta recebida, processando JSON...");
    return response.json();
  })
  .then(data => {
    // O segundo .then recebe os dados do JSON processado.
    console.log("Dados JSON processados:");
    console.log(data); // Exibe os dados do CEP
    console.log(`Logradouro: ${data.logradouro}`);
  })
  .catch(error => {
    // O .catch lida com qualquer erro que ocorra na cadeia de Promises.
    console.error("Ocorreu um erro na requisição:", error);
  })
  .finally(() => {
    // O .finally é sempre executado.
    console.log("Requisição finalizada.");
  });

console.log("Requisição enviada, aguardando resposta...");
```
A grande vantagem aqui é o **encadeamento (`chaining`)**. Em vez de aninhar callbacks, encadeamos chamadas `.then()`, tornando o fluxo do código linear e muito mais fácil de ler.

## Criando uma Promise

Você também pode criar suas próprias Promises usando o construtor `new Promise()`. Ele recebe uma função (o "executor") com dois parâmetros: `resolve` e `reject`.

*   `resolve(value)`: Chame esta função quando a operação assíncrona for bem-sucedida.
*   `reject(error)`: Chame esta função quando a operação falhar.

```javascript
function esperarSegundos(segundos) {
  return new Promise((resolve, reject) => {
    if (segundos < 0) {
      reject(new Error("O tempo não pode ser negativo."));
    }
    
    setTimeout(() => {
      resolve(`Esperei por ${segundos} segundo(s).`);
    }, segundos * 1000);
  });
}

esperarSegundos(2)
  .then(mensagem => console.log(mensagem)) // Saída após 2s: "Esperei por 2 segundo(s)."
  .catch(erro => console.error(erro));

esperarSegundos(-1)
  .then(mensagem => console.log(mensagem))
  .catch(erro => console.error(erro.message)); // Saída imediata: "O tempo não pode ser negativo."
```
As Promises são a base para a sintaxe `async/await`, que torna o código assíncrono ainda mais simples.

