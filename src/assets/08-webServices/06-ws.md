# Aula 6: Tratamento de Respostas e Erros

## Objetivo
Objetivo: Aprender/Entender como tratar as respostas de uma API, incluindo os Status Codes HTTP, e como lidar com erros de forma eficaz em JavaScript usando a Fetch API.

## O que é Tratamento de Respostas e Erros?

Ao interagir com APIs, nem todas as requisições serão bem-sucedidas. É crucial que sua aplicação saiba como interpretar as respostas do servidor e como reagir a diferentes cenários, sejam eles de sucesso, de falha na validação, de recursos não encontrados ou de erros internos do servidor. O **tratamento de respostas** envolve a leitura dos dados retornados e a verificação do status da operação, enquanto o **tratamento de erros** é a estratégia para lidar com situações inesperadas ou problemáticas, garantindo que a aplicação permaneça robusta e forneça feedback útil ao usuário.

## Como funciona? Status Codes HTTP e Tratamento de Erros com Fetch

### Status Codes HTTP

Os **Status Codes HTTP** são códigos numéricos de três dígitos retornados pelo servidor em cada resposta HTTP. Eles indicam o resultado da requisição e são categorizados em cinco classes:

*   **`1xx` (Informacional):** A requisição foi recebida e o processo continua.
*   **`2xx` (Sucesso):** A requisição foi recebida, entendida e aceita com sucesso.
    *   `200 OK`: A requisição foi bem-sucedida. O recurso foi encontrado e retornado.
    *   `201 Created`: A requisição foi bem-sucedida e um novo recurso foi criado como resultado (comum após um `POST`).
    *   `204 No Content`: A requisição foi bem-sucedida, mas não há conteúdo para enviar na resposta (comum após um `DELETE` ou `PUT` que não retorna dados).
*   **`3xx` (Redirecionamento):** É preciso tomar ações adicionais para completar a requisição.
    *   `301 Moved Permanently`: O recurso foi movido permanentemente para uma nova URL.
*   **`4xx` (Erro do Cliente):** A requisição contém sintaxe incorreta ou não pode ser cumprida.
    *   `400 Bad Request`: O servidor não conseguiu entender a requisição devido a sintaxe inválida.
    *   `401 Unauthorized`: A requisição requer autenticação. O cliente não está autenticado.
    *   `403 Forbidden`: O cliente não tem permissão para acessar o recurso, mesmo que esteja autenticado.
    *   `404 Not Found`: O servidor não conseguiu encontrar o recurso solicitado.
    *   `429 Too Many Requests`: O cliente enviou muitas requisições em um determinado período de tempo (rate limiting).
*   **`5xx` (Erro do Servidor):** O servidor falhou em cumprir uma requisição aparentemente válida.
    *   `500 Internal Server Error`: O servidor encontrou uma condição inesperada que o impediu de cumprir a requisição.
    *   `503 Service Unavailable`: O servidor está temporariamente incapaz de lidar com a requisição devido a sobrecarga ou manutenção.

### Tratamento de Erros com Fetch API

A Fetch API não considera respostas `4xx` ou `5xx` como erros de rede. A `Promise` retornada por `fetch` só será rejeitada em caso de problemas de rede (como falta de conexão) ou se a requisição for abortada. Para tratar erros HTTP, você deve verificar a propriedade `response.ok` ou `response.status`.

```javascript
async function fetchData() {
  try {
    const response = await fetch("https://api.example.com/data");

    // 1. Verificar se a resposta foi bem-sucedida (status 2xx)
    if (!response.ok) {
      // Se o status não for 2xx, lançar um erro com o status e a mensagem do servidor
      const errorData = await response.json(); // Tentar ler o corpo do erro, se houver
      throw new Error(`Erro HTTP: ${response.status} - ${errorData.message || response.statusText}`);
    }

    // 2. Processar a resposta JSON
    const data = await response.json();
    console.log("Dados recebidos:", data);
    return data;

  } catch (error) {
    // 3. Capturar erros de rede ou erros lançados manualmente
    console.error("Ocorreu um erro na requisição:", error.message);
    // Aqui você pode exibir uma mensagem de erro para o usuário
    // ou tentar novamente a requisição, dependendo da natureza do erro.
  }
}

fetchData();
```

**Explicação Detalhada:**

1.  **Verificação `response.ok`:** A propriedade `response.ok` é um booleano que indica se a resposta HTTP foi bem-sucedida (status code entre 200 e 299). Se for `false`, significa que houve um erro no lado do cliente ou do servidor, e devemos tratar isso como um erro.
2.  **Lançando Erros Personalizados:** Dentro do bloco `if (!response.ok)`, lançamos um novo `Error`. É uma boa prática tentar extrair uma mensagem de erro mais detalhada do corpo da resposta (se a API fornecer uma, geralmente em JSON) ou usar `response.statusText`.
3.  **Bloco `try...catch`:**
    *   O `try` envolve o código que pode gerar erros (a chamada `fetch` e o processamento da resposta).
    *   O `catch(error)` captura qualquer erro que seja lançado dentro do bloco `try`, seja um erro de rede (rejeição da Promise do `fetch`) ou um erro que lançamos manualmente (como no passo 2).

### Exemplo com Diferentes Status Codes

```javascript
async function createUser(userData) {
  try {
    const response = await fetch("https://api.example.com/users", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userData),
    });

    if (response.status === 201) {
      const newUser = await response.json();
      console.log("Usuário criado com sucesso:", newUser);
      return newUser;
    } else if (response.status === 400) {
      const errorDetails = await response.json();
      console.error("Erro de validação:", errorDetails.errors);
      // Exibir erros de validação específicos para o usuário
      throw new Error("Dados inválidos: " + errorDetails.errors.join(", "));
    } else if (response.status === 409) { // Exemplo: Conflito, usuário já existe
      console.error("Usuário já existe.");
      throw new Error("Este e-mail já está em uso.");
    } else {
      // Para outros erros 4xx/5xx não tratados especificamente
      throw new Error(`Erro inesperado: ${response.status} - ${response.statusText}`);
    }

  } catch (error) {
    console.error("Falha ao criar usuário:", error.message);
    // Lógica para exibir mensagem de erro genérica ou específica
  }
}

// Exemplo de uso:
// createUser({ name: "Alice", email: "alice@example.com" });
// createUser({ name: "Bob", email: "invalid-email" }); // Simular erro 400
```

**Pontos Chave para o Tratamento de Erros:**

*   **Seja Específico:** Tente tratar os `Status Codes` mais comuns para sua API de forma específica (ex: `400` para validação, `404` para não encontrado).
*   **Mensagens Claras:** As mensagens de erro para o usuário final devem ser claras, concisas e, se possível, sugerir uma solução.
*   **Logs:** Registre os erros no console ou em um sistema de monitoramento para depuração.
*   **Feedback ao Usuário:** Sempre forneça feedback visual ao usuário sobre o status da requisição (carregando, sucesso, erro).

Dominar o tratamento de respostas e erros é fundamental para construir aplicações robustas e com uma boa experiência de usuário, pois permite que sua aplicação reaja de forma inteligente a qualquer situação que possa surgir na comunicação com APIs.
