# Aula 7: Autenticação e Autorização

## Objetivo
Objetivo: Aprender/Entender a diferença entre Autenticação e Autorização e os métodos comuns de autenticação em APIs REST, com exemplos práticos em JavaScript.

## O que é Autenticação e Autorização?

Ao interagir com APIs que contêm dados sensíveis ou funcionalidades restritas, é fundamental garantir que apenas usuários permitidos possam acessá-los. Para isso, utilizamos dois conceitos distintos, mas complementares:

*   **Autenticação ("Quem você é?"):** É o processo de verificar a identidade de um usuário ou sistema. É como apresentar um documento de identidade para provar quem você é. Em APIs, isso geralmente envolve o envio de credenciais (como nome de usuário e senha, ou uma chave secreta) que o servidor verifica para confirmar sua identidade.

*   **Autorização ("O que você pode fazer?"):** É o processo de determinar quais permissões um usuário ou sistema autenticado possui. Uma vez que sua identidade é confirmada (autenticação), a autorização define quais recursos você pode acessar e quais ações você pode realizar. É como ter um crachá que, além de identificar você, também indica as áreas do prédio onde você tem permissão para entrar.

Em resumo, a **autenticação** estabelece a identidade, enquanto a **autorização** define o nível de acesso e as permissões associadas a essa identidade.

## Como funciona? Métodos Comuns de Autenticação em APIs REST

Existem diversos métodos para autenticar requisições em APIs REST. Vamos explorar os mais comuns:

### 1. API Keys (Chaves de API)

**O que é:** Uma API Key é uma string única e secreta que é usada para identificar o aplicativo ou usuário que está fazendo a requisição. É uma forma simples de autenticação, geralmente usada para controlar o acesso a APIs públicas ou para monitorar o uso.

**Como funciona:** A chave de API é enviada em cada requisição, geralmente em um cabeçalho HTTP (`X-API-Key`, `Authorization`) ou como um parâmetro de consulta (query parameter) na URL.

**Exemplo Prático (em JavaScript com Fetch):**

```javascript
async function fetchDataWithApiKey() {
  const apiKey = 'SUA_API_KEY_SECRETA'; // Substitua pela sua chave de API
  const url = `https://api.example.com/data?apiKey=${apiKey}`; // Como query parameter
  // Ou como cabeçalho:
  // const url = 'https://api.example.com/data';

  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        // 'X-API-Key': apiKey, // Exemplo de envio via cabeçalho
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }

    const data = await response.json();
    console.log('Dados obtidos com API Key:', data);
  } catch (error) {
    console.error('Erro ao buscar dados com API Key:', error);
  }
}

fetchDataWithApiKey();
```

**Considerações:** API Keys são fáceis de implementar, mas menos seguras para autenticação de usuários individuais, pois se a chave for comprometida, qualquer um pode usá-la. São mais adequadas para identificar aplicações ou para APIs com baixo nível de sensibilidade.

### 2. Bearer Token (JSON Web Tokens - JWT)

**O que é:** Bearer Token é um tipo de token de segurança que concede acesso ao portador (bearer) do token. O tipo mais comum de Bearer Token em APIs REST modernas é o **JSON Web Token (JWT)**. Um JWT é um token compacto e auto-contido que é usado para transmitir informações de forma segura entre as partes como um objeto JSON.

**Fluxo Básico de Autenticação com JWT:**

1.  **Login:** O cliente envia as credenciais do usuário (ex: e-mail e senha) para um endpoint de login na API.
2.  **Geração do Token:** Se as credenciais forem válidas, o servidor gera um JWT e o envia de volta ao cliente.
3.  **Armazenamento do Token:** O cliente armazena este JWT (geralmente em `localStorage` ou `sessionStorage` no navegador).
4.  **Requisições Protegidas:** Para acessar recursos protegidos, o cliente inclui o JWT em cada requisição subsequente, no cabeçalho `Authorization` com o prefixo `Bearer`.
5.  **Verificação:** O servidor recebe a requisição, verifica a validade do JWT (assinatura, expiração) e, se válido, concede acesso ao recurso solicitado.

**Exemplo Prático (em JavaScript com Fetch):**

```javascript
// Simulação de um processo de login para obter um token
async function loginUser(email, password) {
  try {
    const response = await fetch('https://api.example.com/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      throw new Error(`Erro de login: ${response.status}`);
    }

    const data = await response.json();
    const token = data.token; // Supondo que a API retorna um objeto com a propriedade 'token'
    localStorage.setItem('authToken', token); // Armazena o token no localStorage
    console.log('Login bem-sucedido. Token:', token);
    return token;
  } catch (error) {
    console.error('Falha no login:', error);
    throw error;
  }
}

// Função para fazer uma requisição autenticada com o Bearer Token
async function fetchProtectedData() {
  const token = localStorage.getItem('authToken'); // Recupera o token armazenado

  if (!token) {
    console.error('Nenhum token de autenticação encontrado. Faça login primeiro.');
    return;
  }

  try {
    const response = await fetch('https://api.example.com/protected-data', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`, // Envia o token no cabeçalho Authorization
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }

    const data = await response.json();
    console.log('Dados protegidos obtidos:', data);
  } catch (error) {
    console.error('Erro ao buscar dados protegidos:', error);
  }
}

// Exemplo de uso:
// (async () => {
//   try {
//     await loginUser('user@example.com', 'password123');
//     await fetchProtectedData();
//   } catch (e) {
//     console.log('Processo de autenticação falhou.');
//   }
// })();
```

**Integração em um Componente React (Exemplo Básico):**

Em um componente React, você gerenciaria o estado de autenticação (se o usuário está logado e o token) e usaria um `useEffect` para buscar dados protegidos após o login ou quando o token estiver disponível.

```javascript
import React, { useEffect, useState } from 'react';

function ProtectedContent() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [token, setToken] = useState(localStorage.getItem('authToken'));

  // Função de login (simplificada para o exemplo)
  const handleLogin = async () => {
    try {
      const response = await fetch('https://api.example.com/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: 'user@example.com', password: 'password123' }),
      });
      const result = await response.json();
      if (response.ok) {
        localStorage.setItem('authToken', result.token);
        setToken(result.token);
      } else {
        throw new Error(result.message || 'Falha no login');
      }
    } catch (err) {
      setError(err);
    }
  };

  useEffect(() => {
    async function fetchProtectedData() {
      if (!token) {
        setLoading(false);
        return; // Não tenta buscar se não há token
      }

      try {
        const response = await fetch('https://api.example.com/protected-data', {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`Erro HTTP: ${response.status}`);
        }

        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    }

    fetchProtectedData();
  }, [token]); // Dependência do token: refaz a requisição se o token mudar

  if (loading) return <p>Carregando conteúdo protegido...</p>;
  if (error) return <p>Erro: {error.message}. Por favor, {token ? 'tente novamente' : <button onClick={handleLogin}>faça login</button>}.</p>;
  if (!token) return <p>Por favor, <button onClick={handleLogin}>faça login</button> para ver o conteúdo protegido.</p>;

  return (
    <div>
      <h1>Conteúdo Protegido</h1>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}

export default ProtectedContent;
```

**Considerações:** JWTs são amplamente utilizados por sua flexibilidade e por serem stateless (o servidor não precisa armazenar o estado da sessão). No entanto, é crucial gerenciar a expiração do token e o processo de refresh para manter a segurança e a experiência do usuário. O armazenamento em `localStorage` é conveniente, mas pode ser vulnerável a ataques XSS (Cross-Site Scripting); para aplicações de alta segurança, outras estratégias (como `HttpOnly cookies`) podem ser preferíveis.

Dominar esses métodos de autenticação é essencial para construir aplicações web seguras e que interagem de forma responsável com APIs que exigem controle de acesso.
