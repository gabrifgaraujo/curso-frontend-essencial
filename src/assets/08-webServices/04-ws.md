# Aula 4: Consumo de APIs com JavaScript (Fetch API)

## Objetivo
Objetivo: Aprender/Entender como fazer requisições HTTP em JavaScript usando a Fetch API e processar as respostas, incluindo o uso de Promises e Async/Await.

## O que é a Fetch API?

A **Fetch API** é uma interface moderna e poderosa para fazer requisições de rede (como requisições HTTP para APIs) em navegadores web. Ela oferece uma alternativa mais flexível e robusta ao `XMLHttpRequest` (XHR) tradicional, utilizando **Promises** para lidar com a assincronicidade das operações de rede. Isso torna o código mais limpo e fácil de entender, especialmente quando combinado com `async/await`.

Com a Fetch API, você pode enviar requisições `GET`, `POST`, `PUT`, `DELETE` e outras, além de configurar cabeçalhos, corpos de requisição e lidar com respostas de forma eficiente.

## Como funciona? Fazendo Requisições GET e Lidando com Assincronicidade

### Exemplo Prático GET: Consumindo uma API Pública

Vamos ver como fazer uma requisição `GET` para uma API pública, como a [JSONPlaceholder API](https://jsonplaceholder.typicode.com/), que oferece dados de teste. Nosso objetivo será buscar uma lista de posts.

```javascript
// Exemplo 1: Usando .then() para processar a resposta
fetch('https://jsonplaceholder.typicode.com/posts')
  .then(response => {
    // A primeira .then() recebe o objeto Response da requisição.
    // Precisamos chamar .json() nele para parsear o corpo da resposta como JSON.
    // .json() também retorna uma Promise.
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    // A segunda .then() recebe os dados JSON parseados.
    console.log('Posts obtidos (usando .then()):', data);
    // Aqui você faria algo com os dados, como exibi-los na UI
  })
  .catch(error => {
    // O .catch() lida com erros que ocorrem durante o fetch ou o processamento da Promise.
    console.error('Erro ao buscar posts (usando .then()):', error);
  });
```

**Explicação:**
1.  `fetch('URL')`: Inicia a requisição para a URL especificada. Retorna uma `Promise` que resolve para o objeto `Response`.
2.  `.then(response => { ... })`: O primeiro `.then()` é executado quando a `Promise` do `fetch` é resolvida. O `response` é um objeto que contém informações sobre a resposta da rede (status, cabeçalhos, etc.).
3.  `if (!response.ok) { ... }`: É uma boa prática verificar a propriedade `response.ok`, que é `true` se o status da resposta HTTP estiver no intervalo `200-299` (sucesso).
4.  `response.json()`: Este método lê o corpo da resposta e o parseia como JSON. Ele também retorna uma `Promise`.
5.  `.then(data => { ... })`: O segundo `.then()` é executado quando a `Promise` de `response.json()` é resolvida, entregando os dados JSON já parseados.
6.  `.catch(error => { ... })`: Captura quaisquer erros que possam ocorrer durante a requisição ou o processamento das Promises.

### Promises e Async/Await: Lidando com a Assincronicidade de Forma Moderna

Trabalhar com múltiplas Promises encadeadas pode se tornar complexo. O JavaScript moderno oferece `async/await` como uma sintaxe mais limpa e síncrona para lidar com Promises, tornando o código assíncrono mais fácil de ler e escrever.

*   Uma função marcada com `async` sempre retorna uma `Promise`.
*   A palavra-chave `await` só pode ser usada dentro de uma função `async`. Ela "pausa" a execução da função `async` até que a `Promise` seja resolvida, e então retorna o valor resolvido da `Promise`.

```javascript
// Exemplo 2: Usando async/await para buscar posts
async function getPosts() {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts');
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    console.log('Posts obtidos (usando async/await):', data);
    return data;
  } catch (error) {
    console.error('Erro ao buscar posts (usando async/await):', error);
    // Você pode relançar o erro ou retornar um valor padrão
    throw error; 
  }
}

// Chamando a função assíncrona
getPosts();
```

**Explicação:**
1.  `async function getPosts() { ... }`: Declara uma função assíncrona.
2.  `const response = await fetch(...)`: A execução da função `getPosts` é pausada aqui até que a `Promise` retornada por `fetch` seja resolvida. O valor resolvido (o objeto `Response`) é atribuído a `response`.
3.  `const data = await response.json()`: Novamente, a execução é pausada até que o corpo da resposta seja parseado como JSON. Os dados parseados são atribuídos a `data`.
4.  `try...catch`: Permite lidar com erros de forma semelhante aos blocos `try...catch` síncronos, tornando o tratamento de erros mais intuitivo.

### Integração em um Componente React (Exemplo Básico)

Em um componente React, você geralmente faria requisições de API dentro de um `useEffect` (para efeitos colaterais) e armazenaria os dados no estado do componente.

```javascript
import React, { useEffect, useState } from 'react';

function PostsList() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchPosts() {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        setPosts(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    }

    fetchPosts();
  }, []); // O array vazio [] garante que o useEffect rode apenas uma vez, como componentDidMount

  if (loading) return <p>Carregando posts...</p>;
  if (error) return <p>Erro ao carregar posts: {error.message}</p>;

  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>
            <h2>{post.title}</h2>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default PostsList;
```

**Explicação:**
*   `useState`: Usado para gerenciar o estado dos posts, do carregamento e de possíveis erros.
*   `useEffect`: Garante que a função `fetchPosts` seja executada apenas uma vez após a montagem inicial do componente.
*   A função `fetchPosts` é `async` e usa `await` para buscar e processar os dados.
*   O estado `loading` e `error` são usados para exibir mensagens apropriadas ao usuário enquanto os dados estão sendo carregados ou em caso de falha.

Dominar a Fetch API e `async/await` é essencial para qualquer desenvolvedor JavaScript que trabalhe com aplicações web modernas e APIs.
